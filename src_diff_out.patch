diff --git a/src/api/routes/chat.routes.js b/src/api/routes/chat.routes.js
index 3c69932..b9a081e 100644
--- a/src/api/routes/chat.routes.js
+++ b/src/api/routes/chat.routes.js
@@ -27,7 +27,8 @@ module.exports = (client, sharedState) => {
             let waMessages = [];
             try {
                 const chat = await withTimeout(client.getChatById(chatId), 5000, "Timeout getting chat for summary");
-                waMessages = await withTimeout(chat.fetchMessages({ limit: 50 }), 10000, "Timeout fetching messages for summary");
+                const rawMessages = await withTimeout(chat.fetchMessages({ limit: 50 }), 10000, "Timeout fetching messages for summary");
+                waMessages = rawMessages.filter(m => m.timestamp >= resetAt);
             } catch (e) {
                 console.warn(`[SUMMARIZE] WA Fetch failed for ${chatId}`);
             }
@@ -50,6 +51,10 @@ module.exports = (client, sharedState) => {
                 content: m.body || m.content
             }));
 
+            if (formattedHistory.length === 0) {
+                return res.json({ summary: "No hay datos a├║n" });
+            }
+
             const summary = await aiService.generateManualSummary(formattedHistory);
             res.json({ summary });
         } catch (e) {
@@ -200,6 +205,7 @@ module.exports = (client, sharedState) => {
                 cart: [],
                 assignedScript: autoScript,
                 history: [],
+                summary: null,
                 stepEnteredAt: Date.now(),
                 lastActivityAt: Date.now(),
                 lastInteraction: Date.now()
diff --git a/src/api/routes/order.routes.js b/src/api/routes/order.routes.js
index 06c95c6..e358afd 100644
--- a/src/api/routes/order.routes.js
+++ b/src/api/routes/order.routes.js
@@ -3,7 +3,7 @@ const fs = require('fs');
 const path = require('path');
 const { authMiddleware } = require('../../middleware/auth');
 const { atomicWriteFile } = require('../../../safeWrite');
-const { getOrdersFromSheet, updateOrderInSheet } = require('../../../sheets_sync');
+const { getOrdersFromSheet, updateOrderInSheet, deleteOrderInSheet } = require('../../../sheets_sync');
 
 module.exports = (client, sharedState) => {
     const router = express.Router();
@@ -64,7 +64,7 @@ module.exports = (client, sharedState) => {
     });
 
     // DELETE /orders/:id (Delete order) - Authenticated
-    router.delete('/orders/:id', authMiddleware, (req, res) => {
+    router.delete('/orders/:id', authMiddleware, async (req, res) => {
         const { id } = req.params;
 
         if (!fs.existsSync(ORDERS_FILE)) return res.status(404).json({ error: "No orders found" });
@@ -73,12 +73,17 @@ module.exports = (client, sharedState) => {
         const index = orders.findIndex(o => o.id === id);
         if (index === -1) return res.status(404).json({ error: "Order not found" });
 
+        // Actually delete from Google Sheets too
+        try {
+            await deleteOrderInSheet(id);
+        } catch (e) {
+            console.error('­ƒö┤ [ROUTES] Error deleting from Sheets:', e);
+            // We can choose to proceed with local deletion or fail
+        }
+
         const deleted = orders.splice(index, 1)[0];
         atomicWriteFile(ORDERS_FILE, JSON.stringify(orders, null, 2));
 
-        // Note: DELETE operation is currently only locally deleting as destroying rows 
-        // in sheets can break formats. User can soft-delete or manually purge sheets.
-
         if (io) io.emit('order_delete', { id });
         res.json({ success: true, deleted });
     });
diff --git a/src/flows/salesFlow.js b/src/flows/salesFlow.js
index b6d66c4..0363609 100644
--- a/src/flows/salesFlow.js
+++ b/src/flows/salesFlow.js
@@ -5,6 +5,7 @@ const { atomicWriteFile } = require('../../safeWrite');
 const { appendOrderToSheet } = require('../../sheets_sync');
 const path = require('path');
 const fs = require('fs');
+const { buildConfirmationMessage } = require('../utils/messageTemplates');
 
 // Check DATA_DIR first (Railway volume), then source code data/ dir as fallback
 const DATA_DIR = process.env.DATA_DIR || path.join(__dirname, '../..');
@@ -267,32 +268,26 @@ async function processSalesFlow(userId, text, userState, knowledge, dependencies
 
     // Init User State if needed
     if (!userState[userId]) {
-        // Auto A/B Testing or Forced Script Logic
-        let initialScript = 'v3'; // Default fallback
-        if (dependencies.config && dependencies.config.activeScript === 'rotacion') {
-            initialScript = Math.random() < 0.5 ? 'v3' : 'v4';
-            console.log(`[A/B TEST] New user ${userId} randomly assigned to rotation script: ${initialScript}`);
-        } else if (dependencies.config && dependencies.config.activeScript) {
-            initialScript = dependencies.config.activeScript;
-            console.log(`[A/B TEST] New user ${userId} assigned to fixed active script: ${initialScript}`);
-        } else {
-            console.log(`[A/B TEST] New user ${userId} assigned to fallback script: ${initialScript}`);
-        }
+        const autoScript = dependencies.config?.activeScript === 'rotacion'
+            ? (Math.random() < 0.5 ? 'v3' : 'v4')
+            : (dependencies.config?.activeScript || 'v3');
+        console.log(`[SALES-FLOW] Assigning script ${autoScript} to NEW user ${userId} `);
 
         userState[userId] = {
             step: 'greeting',
-            lastMessage: null,
             addressAttempts: 0,
             partialAddress: {},
-            cart: [], // NEW: Support for multiple items
-            assignedScript: initialScript, // Lock this user to their variant
+            cart: [],
+            assignedScript: autoScript,
             history: [],
+            summary: null,
             stepEnteredAt: Date.now(),
             lastActivityAt: Date.now(),
-            lastInteraction: Date.now() // For abandoned cart
+            lastInteraction: Date.now()
         };
-        saveState();
-    } else {
+    }
+    saveState();
+    if (userState[userId]) { // Check if userState[userId] exists after potential creation
         userState[userId].lastInteraction = Date.now();
     }
     const currentState = userState[userId];
@@ -537,8 +532,8 @@ async function processSalesFlow(userId, text, userState, knowledge, dependencies
 
     for (const faq of knowledge.faq) {
         if (faq.keywords.some(k => new RegExp(`\\b${k}\\b`, 'i').test(normalizedText))) {
-            currentState.history.push({ role: 'bot', content: _formatMessage(faq.response), timestamp: Date.now() });
-            await sendMessageWithDelay(userId, _formatMessage(faq.response));
+            currentState.history.push({ role: 'bot', content: _formatMessage(faq.response, currentState), timestamp: Date.now() });
+            await sendMessageWithDelay(userId, _formatMessage(faq.response, currentState));
 
             if (faq.triggerStep) {
                 _setStep(currentState, faq.triggerStep);
@@ -574,7 +569,7 @@ async function processSalesFlow(userId, text, userState, knowledge, dependencies
             }
 
             // 1. Send Text FIRST
-            const greetMsg = _formatMessage(knowledge.flow.greeting.response);
+            const greetMsg = _formatMessage(knowledge.flow.greeting.response, currentState);
             currentState.history.push({ role: 'bot', content: greetMsg, timestamp: Date.now() });
             await sendMessageWithDelay(userId, greetMsg);
 
@@ -617,6 +612,12 @@ async function processSalesFlow(userId, text, userState, knowledge, dependencies
             break;
 
         case 'waiting_weight': {
+            // Pre-catch product mention via simple regex to prevent looping if they don't say weight
+            const tLow = text.toLowerCase();
+            if (tLow.includes('c├ípsula') || tLow.includes('capsula')) currentState.suggestedProduct = "C├ípsulas de nuez de la india";
+            else if (tLow.includes('gota')) currentState.suggestedProduct = "Gotas de nuez de la india";
+            else if (tLow.includes('semilla')) currentState.suggestedProduct = "Semillas de nuez de la india";
+
             // SCRIPT FIRST: Check if user gave a number
             const hasNumber = /\d+/.test(text.trim());
 
@@ -625,13 +626,42 @@ async function processSalesFlow(userId, text, userState, knowledge, dependencies
             const isRefusal = /\b(no (quiero|voy|puedo)|prefiero no|pasame|decime|precio|que tenes|mostrame)\b/i.test(normalizedText);
 
             if (hasNumber) {
-                // Direct script response ÔÇö NO AI
-                const recNode = knowledge.flow.recommendation;
-                _setStep(currentState, recNode.nextStep);
-                currentState.history.push({ role: 'bot', content: _formatMessage(recNode.response), timestamp: Date.now() });
-                saveState();
-                await sendMessageWithDelay(userId, _formatMessage(recNode.response));
-                matched = true;
+                const wMatch = text.match(/\d+/);
+                if (wMatch) currentState.weightGoal = parseInt(wMatch[0], 10);
+
+                if (currentState.suggestedProduct) {
+                    console.log(`[LOGIC] User ${userId} already suggested ${currentState.suggestedProduct}, skipping preference question.`);
+                    currentState.selectedProduct = currentState.suggestedProduct;
+
+                    let priceNode;
+                    if (currentState.selectedProduct.includes('C├ípsulas')) priceNode = knowledge.flow.preference_capsulas;
+                    else if (currentState.selectedProduct.includes('Gotas')) priceNode = knowledge.flow.preference_gotas;
+                    else priceNode = knowledge.flow.preference_semillas;
+
+                    // Direct jump to pricing
+                    const msg = _formatMessage(priceNode.response, currentState);
+                    _setStep(currentState, priceNode.nextStep);
+                    currentState.history.push({ role: 'bot', content: msg, timestamp: Date.now() });
+                    saveState();
+                    await sendMessageWithDelay(userId, msg);
+
+                    if (currentState.weightGoal && currentState.weightGoal > 10) {
+                        const upsell = "Personalmente yo te recomendar├¡a el de 120 d├¡as debido al peso que esperas perder ­ƒæî";
+                        currentState.history.push({ role: 'bot', content: upsell, timestamp: Date.now() });
+                        saveState();
+                        await sendMessageWithDelay(userId, upsell);
+                    }
+
+                    matched = true;
+                } else {
+                    // Direct script response ÔÇö NO AI (Normal flow, ask preference)
+                    const recNode = knowledge.flow.recommendation;
+                    _setStep(currentState, recNode.nextStep);
+                    currentState.history.push({ role: 'bot', content: _formatMessage(recNode.response, currentState), timestamp: Date.now() });
+                    saveState();
+                    await sendMessageWithDelay(userId, _formatMessage(recNode.response, currentState));
+                    matched = true;
+                }
             } else {
                 // Increment refusal counter
                 currentState.weightRefusals = (currentState.weightRefusals || 0) + 1;
@@ -652,7 +682,7 @@ async function processSalesFlow(userId, text, userState, knowledge, dependencies
                     console.log(`[AI-FALLBACK] waiting_weight: No number detected for ${userId}`);
                     const aiWeight = await aiService.chat(text, {
                         step: 'waiting_weight',
-                        goal: 'El usuario debe decir cu├íntos kilos quiere bajar. Si dice qu├® PRODUCTO quiere directamente (c├ípsulas, semillas, gotas), respond├® goalMet=true y extractedData con el producto. Si pregunta otra cosa, respond├® brevemente y volv├® a preguntar cu├íntos kilos quiere bajar.',
+                        goal: 'Explicar brevemente el producto seleccionado y preguntar sutilmente cu├ínto peso buscan bajar para continuar. REGLA: Si la persona pregunta "c├ípsulas o gotas", o pide recomendaci├│n general, decirle EXACTAMENTE: "Las c├ípsulas son la opci├│n m├ís efectiva y pr├íctica, ideales para un tratamiento r├ípido. ┬┐Cu├íntos kilos quer├®s bajar?" No ofrezcas otros productos a menos que pregunten espec├¡ficamente.',
                         history: currentState.history,
                         summary: currentState.summary,
                         knowledge: knowledge,
@@ -661,14 +691,45 @@ async function processSalesFlow(userId, text, userState, knowledge, dependencies
 
                     if (aiWeight.goalMet) {
                         // AI detected a weight goal we missed with regex
-                        const recNode = knowledge.flow.recommendation;
-                        _setStep(currentState, recNode.nextStep);
-                        currentState.history.push({ role: 'bot', content: _formatMessage(recNode.response), timestamp: Date.now() });
-                        saveState();
-                        await sendMessageWithDelay(userId, _formatMessage(recNode.response));
-                        matched = true;
+                        if (aiWeight.extractedData) {
+                            const extNum = aiWeight.extractedData.match(/\d+/);
+                            if (extNum) currentState.weightGoal = parseInt(extNum[0], 10);
+                        }
+
+                        if (currentState.suggestedProduct) {
+                            console.log(`[LOGIC] AI goalMet weight, user already suggested ${currentState.suggestedProduct}, skipping preference.`);
+                            currentState.selectedProduct = currentState.suggestedProduct;
+
+                            let priceNode;
+                            if (currentState.selectedProduct.includes('C├ípsulas')) priceNode = knowledge.flow.preference_capsulas;
+                            else if (currentState.selectedProduct.includes('Gotas')) priceNode = knowledge.flow.preference_gotas;
+                            else priceNode = knowledge.flow.preference_semillas;
+
+                            const msg = _formatMessage(priceNode.response, currentState);
+                            _setStep(currentState, priceNode.nextStep);
+                            currentState.history.push({ role: 'bot', content: msg, timestamp: Date.now() });
+                            saveState();
+                            await sendMessageWithDelay(userId, msg);
+
+                            if (currentState.weightGoal && currentState.weightGoal > 10) {
+                                const upsell = "Personalmente yo te recomendar├¡a el de 120 d├¡as debido al peso que esperas perder ­ƒæî";
+                                currentState.history.push({ role: 'bot', content: upsell, timestamp: Date.now() });
+                                saveState();
+                                await sendMessageWithDelay(userId, upsell);
+                            }
+
+                            matched = true;
+                        } else {
+                            const recNode = knowledge.flow.recommendation;
+                            _setStep(currentState, recNode.nextStep);
+                            currentState.history.push({ role: 'bot', content: _formatMessage(recNode.response, currentState), timestamp: Date.now() });
+                            saveState();
+                            await sendMessageWithDelay(userId, _formatMessage(recNode.response, currentState));
+                            matched = true;
+                        }
                     } else if (aiWeight.response) {
                         currentState.history.push({ role: 'bot', content: aiWeight.response, timestamp: Date.now() });
+                        saveState(); // Added saveState here
                         await sendMessageWithDelay(userId, aiWeight.response);
                         matched = true;
                     }
@@ -678,18 +739,28 @@ async function processSalesFlow(userId, text, userState, knowledge, dependencies
         }
 
         case 'waiting_preference': {
+            // SCRIPT FIRST: Check if the user is asking for a deferred "postdatado" date early
+            const earlyPostdatadoMatch = text.match(/\b(lunes|martes|miercoles|mi├®rcoles|jueves|viernes|sabado|s├íbado|domingo|semana|mes|cobro|ma├▒ana|despues|despu├®s|principio|el \d+ de [a-z]+|el \d+)\b/i);
+            if (earlyPostdatadoMatch && /\b(recibir|llega|enviar|mandar|cobro|pago|puedo)\b/i.test(normalizedText)) {
+                console.log(`[EARLY POSTDATADO] Captured in waiting_preference: ${text}`);
+                if (!currentState.postdatado) currentState.postdatado = text; // Save it to output later
+                saveState();
+            }
+
             // SCRIPT FIRST: Check keywords for capsulas or semillas
             const isMatch = (keywords, text) => keywords.some(k => new RegExp(`\\b${k}\\b`, 'i').test(text));
 
-            // DETECT INDECISION / COMPARISON (e.g. "estoy entre gotas y semillas", "cual es mejor")
             const mentionsCapsulas = isMatch(knowledge.flow.preference_capsulas.match, normalizedText);
             const mentionsSemillas = isMatch(knowledge.flow.preference_semillas.match, normalizedText);
-            const mentionsGotas = knowledge.flow.preference_gotas && isMatch(knowledge.flow.preference_gotas.match, normalizedText);
+            const mentionsGotas = knowledge.flow.preference_gotas ? isMatch(knowledge.flow.preference_gotas.match, normalizedText) : false;
+
+            const totalMatches = (mentionsCapsulas ? 1 : 0) + (mentionsSemillas ? 1 : 0) + (mentionsGotas ? 1 : 0);
 
-            const multipleMentions = [mentionsCapsulas, mentionsSemillas, mentionsGotas].filter(Boolean).length >= 2;
-            const asksRecommendation = /\b(cual|recomendame|aconsejas|diferencia|mejor|efectiva|como|info|duda|pregunta|saber)\b/i.test(normalizedText);
+            // If user mentions more than one product (e.g., "capsulas o semillas", "qu├® diferencia hay")
+            // Or if they ask for a recommendation
+            const isComparison = totalMatches > 1 || /\b(cual|recomend|mejor|diferencia|que me recomiendas|que me conviene|cual me das|asesorame)\b/i.test(normalizedText);
 
-            if (multipleMentions || asksRecommendation) {
+            if (isComparison) {
                 console.log(`[INDICISION] User ${userId} compares products or asks for recommendation.`);
 
                 // Use AI to give a consultative answer based on specific rules
@@ -699,6 +770,7 @@ async function processSalesFlow(userId, text, userState, knowledge, dependencies
                     1) Si duda o insiste entre GOTAS y C├üPSULAS: Decile "las gotas las recomendamos para cuando son menos de 10kg y tienen m├ís de 70 a├▒os, por lo suaves que son. Para vos te recomiendo las c├ípsulas que son m├ís efectivas". ┬íOfrec├® SIEMPRE las c├ípsulas como la mejor opci├│n!
                     2) Si dice "antes tomaba semillas" o similar, felicitalo pero RECOMEND├ü C├üPSULAS para un efecto m├ís r├ípido ahora.
                     3) Si pide "lo m├ís efectivo", "lo mejor", "lo m├ís r├ípido": RECOMEND├ü C├üPSULAS SIEMPRE.
+                    4) Si el usuario pregunta si puede recibir el pedido o pagarlo un d├¡a concreto (ej: "┬┐puedo recibir el 10 de marzo?"), EMPEZ├ü TU RESPUESTA DICIENDO EXACTAMENTE QUE S├ì, QUE NO HAY PROBLEMA Y QUEDA ANOTADO PARA ESA FECHA, y luego pas├í a la recomendaci├│n del producto.
                     
                     Respond├® ayudando a decidir con estas reglas y luego PREGUNT├ü: "┬┐Te gustar├¡a avanzar con las c├ípsulas?"`,
                     history: currentState.history,
@@ -721,43 +793,97 @@ async function processSalesFlow(userId, text, userState, knowledge, dependencies
             if (mentionsCapsulas) {
                 // Direct script ÔÇö c├ípsulas
                 currentState.selectedProduct = "C├ípsulas de nuez de la india";
-                const msg = _formatMessage(knowledge.flow.preference_capsulas.response);
+                const msg = _formatMessage(knowledge.flow.preference_capsulas.response, currentState);
                 _setStep(currentState, knowledge.flow.preference_capsulas.nextStep);
                 currentState.history.push({ role: 'bot', content: msg, timestamp: Date.now() });
                 saveState();
                 await sendMessageWithDelay(userId, msg);
+
+                if (currentState.weightGoal && currentState.weightGoal > 10) {
+                    const upsell = "Personalmente yo te recomendar├¡a el de 120 d├¡as debido al peso que esperas perder ­ƒæî";
+                    currentState.history.push({ role: 'bot', content: upsell, timestamp: Date.now() });
+                    saveState();
+                    await sendMessageWithDelay(userId, upsell);
+                }
+
                 matched = true;
             } else if (mentionsSemillas) {
                 // Direct script ÔÇö semillas
                 currentState.selectedProduct = "Semillas de nuez de la india";
-                const msg = _formatMessage(knowledge.flow.preference_semillas.response);
+                const msg = _formatMessage(knowledge.flow.preference_semillas.response, currentState);
                 _setStep(currentState, knowledge.flow.preference_semillas.nextStep);
                 currentState.history.push({ role: 'bot', content: msg, timestamp: Date.now() });
                 saveState();
                 await sendMessageWithDelay(userId, msg);
+
+                if (currentState.weightGoal && currentState.weightGoal > 10) {
+                    const upsell = "Personalmente yo te recomendar├¡a el de 120 d├¡as debido al peso que esperas perder ­ƒæî";
+                    currentState.history.push({ role: 'bot', content: upsell, timestamp: Date.now() });
+                    saveState();
+                    await sendMessageWithDelay(userId, upsell);
+                }
+
                 matched = true;
             } else if (knowledge.flow.preference_gotas && mentionsGotas) {
                 // Direct script ÔÇö gotas
                 currentState.selectedProduct = "Gotas de nuez de la india";
-                const msg = _formatMessage(knowledge.flow.preference_gotas.response);
+                const msg = _formatMessage(knowledge.flow.preference_gotas.response, currentState);
                 _setStep(currentState, knowledge.flow.preference_gotas.nextStep);
                 currentState.history.push({ role: 'bot', content: msg, timestamp: Date.now() });
                 saveState();
                 await sendMessageWithDelay(userId, msg);
+
+                if (currentState.weightGoal && currentState.weightGoal > 10) {
+                    const upsell = "Personalmente yo te recomendar├¡a el de 120 d├¡as debido al peso que esperas perder ­ƒæî";
+                    currentState.history.push({ role: 'bot', content: upsell, timestamp: Date.now() });
+                    saveState();
+                    await sendMessageWithDelay(userId, upsell);
+                }
+
                 matched = true;
             } else {
                 // AI FALLBACK
                 console.log(`[AI-FALLBACK] waiting_preference: No keyword match for ${userId}`);
                 const aiPref = await aiService.chat(text, {
                     step: 'waiting_preference',
-                    goal: 'Determinar si quiere c├ípsulas/gotas (opci├│n pr├íctica), semillas (opci├│n natural) o AMBAS. REGLAS CR├ìTICAS: Si insiste con gotas pero duda, decile: "las recomendamos para cuando son menos de 10kg y tienen m├ís de 70 a├▒os, por lo suaves que son. Llevate las c├ípsulas". Si habla en PASADO ("yo tomaba", "antes us├®"), NO est├í eligiendo ahora; sugerile las C├üPSULAS. Si pide "lo m├ís efectivo/r├ípido", sugerile C├üPSULAS. Si ya eligi├│ claramente un producto para AHORA, confirm├í.',
+                    goal: 'Determinar si quiere c├ípsulas/gotas (opci├│n pr├íctica), semillas (opci├│n natural) o AMBAS. REGLAS CR├ìTICAS: Si insiste con gotas pero duda, decile: "las recomendamos para cuando son menos de 10kg y tienen m├ís de 70 a├▒os, por lo suaves que son. Llevate las c├ípsulas". Si habla en PASADO ("yo tomaba", "antes us├®"), NO est├í eligiendo ahora; sugerile las C├üPSULAS. Si pide "lo m├ís efectivo/r├ípido", sugerile C├üPSULAS. Si el usuario pregunta si puede recibir el pedido o pagarlo un d├¡a concreto (ej: "┬┐puedo recibir el 10 de marzo?"), DALE EL OK Y CONFIRM├ü EL PRODUCTO. Si ya eligi├│ claramente un producto para AHORA, confirm├í.',
                     history: currentState.history,
                     summary: currentState.summary,
                     knowledge: knowledge,
                     userState: currentState
                 });
 
-                if (aiPref.response) {
+                if (aiPref.goalMet && aiPref.extractedData) {
+                    const ext = aiPref.extractedData.toLowerCase();
+                    let priceNode;
+                    if (ext.includes('c├ípsula') || ext.includes('capsula')) {
+                        currentState.selectedProduct = 'C├ípsulas de nuez de la india';
+                        priceNode = knowledge.flow.price_capsulas;
+                    } else if (ext.includes('gota')) {
+                        currentState.selectedProduct = 'Gotas de nuez de la india';
+                        priceNode = knowledge.flow.price_gotas;
+                    } else if (ext.includes('semilla')) {
+                        currentState.selectedProduct = 'Semillas de nuez de la india';
+                        priceNode = knowledge.flow.price_semillas;
+                    }
+
+                    if (priceNode) {
+                        const msg = _formatMessage(priceNode.response, currentState);
+                        _setStep(currentState, priceNode.nextStep);
+                        currentState.history.push({ role: 'bot', content: msg, timestamp: Date.now() });
+                        saveState();
+                        await sendMessageWithDelay(userId, msg);
+
+                        if (currentState.weightGoal && currentState.weightGoal > 10) {
+                            const upsell = "Personalmente yo te recomendar├¡a el de 120 d├¡as debido al peso que esperas perder ­ƒæî";
+                            currentState.history.push({ role: 'bot', content: upsell, timestamp: Date.now() });
+                            saveState();
+                            await sendMessageWithDelay(userId, upsell);
+                        }
+
+                        matched = true;
+                    }
+                } else if (aiPref.response) {
                     currentState.history.push({ role: 'bot', content: aiPref.response, timestamp: Date.now() });
                     saveState();
                     await sendMessageWithDelay(userId, aiPref.response);
@@ -774,13 +900,13 @@ async function processSalesFlow(userId, text, userState, knowledge, dependencies
             if (wantsPrices || _isAffirmative(normalizedText)) {
                 let msg = "";
                 if (currentState.selectedProduct && currentState.selectedProduct.includes("C├ípsulas")) {
-                    msg = _formatMessage(knowledge.flow.price_capsulas.response);
+                    msg = _formatMessage(knowledge.flow.price_capsulas.response, currentState);
                     _setStep(currentState, knowledge.flow.price_capsulas.nextStep);
                 } else if (currentState.selectedProduct && currentState.selectedProduct.includes("Gotas")) {
-                    msg = _formatMessage(knowledge.flow.price_gotas.response);
+                    msg = _formatMessage(knowledge.flow.price_gotas.response, currentState);
                     _setStep(currentState, knowledge.flow.price_gotas.nextStep);
                 } else {
-                    msg = _formatMessage(knowledge.flow.price_semillas.response);
+                    msg = _formatMessage(knowledge.flow.price_semillas.response, currentState);
                     _setStep(currentState, knowledge.flow.price_semillas.nextStep);
                 }
                 currentState.history.push({ role: 'bot', content: msg, timestamp: Date.now() });
@@ -914,96 +1040,140 @@ async function processSalesFlow(userId, text, userState, knowledge, dependencies
                 await sendMessageWithDelay(userId, closingNode.response);
                 matched = true;
             } else {
-                // AI FALLBACK ÔÇö only if regex didn't match
-                console.log(`[AI-FALLBACK] waiting_plan_choice: No plan number detected for ${userId}`);
-
-                const upsellOptions = [
-                    'Acordate que el servicio de pago a domicilio tiene un valor de $6.000, pero ┬ícon el plan de 120 d├¡as te regalamos ese servicio y te queda a precio final! ┬┐Quer├®s aprovechar este beneficio o seguimos con el de 60?',
-                    'Te aviso por las dudas: el servicio de cobrarte en la puerta de tu casa sale $6.000. Pero si llev├ís el plan de 120 d├¡as ese servicio est├í 100% bonificado. ┬┐Qu├® dec├¡s? ┬┐Vamos con el de 60 igual o aprovech├ís el de 120?',
-                    'Ojo que el de 60 lleva el costo de $6.000 por el servicio log├¡stico de cobro en domicilio. ┬íEn cambio el de 120 te regala ese servicio! ┬┐Seguro quer├®s el de 60 o pasamos al de 120 y ahorr├ís esa plata?'
-                ];
-                const selectedUpsell = upsellOptions[Math.floor(Math.random() * upsellOptions.length)];
-
-                const planAI = await aiService.chat(text, {
-                    step: 'waiting_plan_choice',
-                    goal: `El usuario debe elegir Plan 60 o Plan 120 d├¡as. CR├ìTICO: goalMet=true SOLO si el usuario escribe expl├¡citamente "60" o "120". Si pregunta algo distinto (ej: "c├│mo las consigo", "para mi hija"), goalMet=false, respond├® su duda adaptando los pronombres si compra para otra persona (ej: "para ella") y volv├® a preguntar: "┬┐Avanzamos con 60 o 120 d├¡as?". ESTRATEGIA (Si duda entre planes): El costo por pago a domicilio es de $6.000, pero el plan de 120 BONIFICA/REGALA ese servicio. Decile: "${selectedUpsell}".`,
-                    history: currentState.history,
-                    summary: currentState.summary,
-                    knowledge: knowledge,
-                    userState: currentState
-                });
+                // Check for affirmations after an upsell BEFORE consulting AI
+                // Match common combinations like "ok dale", "si dale", "perfecto gracias"
+                const isAffirmative = /^(si|sisi|ok|dale|bueno|joya|de una|perfecto|genial)[\s\?\!\.]*$/i.test(normalizedText)
+                    || /^(si|ok|dale|perfecto|bueno|hacelo)\s+(si|ok|dale|perfecto|bueno|hacelo)[\s\?\!\.]*$/i.test(normalizedText)
+                    || /\b(si|ok|dale|perfecto|bueno|hacelo)\b/i.test(normalizedText);
+
+                let recentBotMessages = "";
+                // Look at the last TWO bot messages, just in case the upsell was sent in an isolated bubble
+                let botMsgCount = 0;
+                for (let i = currentState.history.length - 1; i >= 0; i--) {
+                    if (currentState.history[i].role === 'bot') {
+                        recentBotMessages += currentState.history[i].content.toLowerCase() + " ";
+                        botMsgCount++;
+                        if (botMsgCount >= 2) break;
+                    }
+                }
+
+                // If user said "yes" and the bot recently recommended/mentioned the 120 plan exclusively
+                if (isAffirmative && (recentBotMessages.includes('recomendar├¡a el de 120') || recentBotMessages.includes('recomendar├¡a el plan de 120') || (recentBotMessages.includes('120') && !recentBotMessages.includes('60')))) {
+                    console.log(`[FLOW-INTERCEPT] User said OK to 120-day plan upsell: ${userId}`);
 
-                if (planAI.extractedData && typeof planAI.extractedData === 'string' && planAI.extractedData.startsWith('CHANGE_PRODUCT:')) {
-                    const newProd = planAI.extractedData.split(':')[1].trim();
-                    console.log(`[FLOW-UPDATE] User changed product to: ${newProd}`);
-                    currentState.selectedProduct = newProd;
+                    const product = currentState.selectedProduct || "Nuez de la India";
+                    const plan = '120';
+
+                    currentState.selectedPlan = plan;
+                    currentState.selectedProduct = product;
+                    currentState.isContraReembolsoMAX = false;
+                    currentState.adicionalMAX = 0;
+
+                    currentState.cart = [{
+                        product: product,
+                        plan: plan,
+                        price: _getPrice(product, plan)
+                    }];
+
+                    const closingNode = knowledge.flow.closing;
+                    _setStep(currentState, closingNode.nextStep);
+
+                    const combinedResponse = `┬íGenial! ­ƒÿè Entonces confirmamos el plan de 120 d├¡as.\n\n${closingNode.response}`;
+
+                    currentState.history.push({ role: 'bot', content: combinedResponse, timestamp: Date.now() });
                     saveState();
-                    // Fallthrough to send AI response
-                }
+                    await sendMessageWithDelay(userId, combinedResponse);
+                    matched = true;
+                } else {
+                    // AI FALLBACK ÔÇö only if regex didn't match and it wasn't an intercepted affirmation
+                    console.log(`[AI-FALLBACK] waiting_plan_choice: No plan number detected for ${userId}`);
 
-                if (planAI.goalMet && planAI.extractedData && !planAI.extractedData.startsWith('CHANGE_PRODUCT:')) {
-                    const extractedStr = String(planAI.extractedData);
-                    _handleExtractedData(userId, extractedStr, currentState);
-
-                    // If user postdates during plan selection and we already had a product
-                    if (extractedStr.startsWith('POSTDATADO:') && currentState.selectedProduct) {
-                        const closingNode = knowledge.flow.closing;
-                        _setStep(currentState, closingNode.nextStep);
-                        if (planAI.response) {
-                            currentState.history.push({ role: 'bot', content: planAI.response, timestamp: Date.now() });
-                            await sendMessageWithDelay(userId, planAI.response);
-                        } else {
-                            currentState.history.push({ role: 'bot', content: closingNode.response, timestamp: Date.now() });
-                            await sendMessageWithDelay(userId, closingNode.response);
-                        }
+                    const upsellOptions = [
+                        'Acordate que el servicio de pago a domicilio tiene un valor de $6.000, pero ┬ícon el plan de 120 d├¡as te regalamos ese servicio y te queda a precio final! ┬┐Quer├®s aprovechar este beneficio o seguimos con el de 60?',
+                        'Te aviso por las dudas: el servicio de cobrarte en la puerta de tu casa sale $6.000. Pero si llev├ís el plan de 120 d├¡as ese servicio est├í 100% bonificado. ┬┐Qu├® dec├¡s? ┬┐Vamos con el de 60 igual o aprovech├ís el de 120?',
+                        'Ojo que el de 60 lleva el costo de $6.000 por el servicio log├¡stico de cobro en domicilio. ┬íEn cambio el de 120 te regala ese servicio! ┬┐Seguro quer├®s el de 60 o pasamos al de 120 y ahorr├ís esa plata?'
+                    ];
+                    const selectedUpsell = upsellOptions[Math.floor(Math.random() * upsellOptions.length)];
+
+                    const planAI = await aiService.chat(text, {
+                        step: 'waiting_plan_choice',
+                        goal: `El usuario debe elegir Plan 60 o Plan 120 d├¡as. CR├ìTICO: goalMet=true SOLO si el usuario escribe expl├¡citamente "60" o "120". Si pregunta algo distinto (ej: "c├│mo las consigo", "para mi hija"), goalMet=false, respond├® su duda adaptando los pronombres si compra para otra persona (ej: "para ella") y volv├® a preguntar: "┬┐Avanzamos con 60 o 120 d├¡as?". ESTRATEGIA (Si duda entre planes): El costo por pago a domicilio es de $6.000, pero el plan de 120 BONIFICA/REGALA ese servicio. Decile: "${selectedUpsell}".`,
+                        history: currentState.history,
+                        summary: currentState.summary,
+                        knowledge: knowledge,
+                        userState: currentState
+                    });
+
+                    if (planAI.extractedData && typeof planAI.extractedData === 'string' && planAI.extractedData.startsWith('CHANGE_PRODUCT:')) {
+                        const newProd = planAI.extractedData.split(':')[1].trim();
+                        console.log(`[FLOW-UPDATE] User changed product to: ${newProd}`);
+                        currentState.selectedProduct = newProd;
                         saveState();
-                        matched = true;
+                        // Fallthrough to send AI response
                     }
-                    // Ultra strict validation to prevent bypassing the plan choice
-                    else if (extractedStr.includes('120') || extractedStr.includes('60')) {
-                        // AI detected a valid plan choice
-                        const plan = extractedStr.includes('120') ? '120' : '60';
-                        const product = currentState.selectedProduct || "Nuez de la India";
-
-                        currentState.selectedPlan = plan;
-                        currentState.selectedProduct = product;
-
-                        currentState.cart = [{
-                            product: product,
-                            plan: plan,
-                            price: _getPrice(product, plan)
-                        }];
-
-                        if (planAI.response) {
-                            currentState.history.push({ role: 'bot', content: planAI.response, timestamp: Date.now() });
-                            await sendMessageWithDelay(userId, planAI.response);
-                        }
 
-                        const closingNode = knowledge.flow.closing;
-                        if (!planAI.response || !planAI.response.toLowerCase().includes('datos')) {
+                    if (planAI.goalMet && planAI.extractedData && !planAI.extractedData.startsWith('CHANGE_PRODUCT:')) {
+                        const extractedStr = String(planAI.extractedData);
+                        _handleExtractedData(userId, extractedStr, currentState);
+
+                        // If user postdates during plan selection and we already had a product
+                        if (extractedStr.startsWith('POSTDATADO:') && currentState.selectedProduct) {
+                            const closingNode = knowledge.flow.closing;
+                            _setStep(currentState, closingNode.nextStep);
+                            if (planAI.response) {
+                                currentState.history.push({ role: 'bot', content: planAI.response, timestamp: Date.now() });
+                                await sendMessageWithDelay(userId, planAI.response);
+                            } else {
+                                currentState.history.push({ role: 'bot', content: closingNode.response, timestamp: Date.now() });
+                                await sendMessageWithDelay(userId, closingNode.response);
+                            }
+                            saveState();
+                            matched = true;
+                        }
+                        // Ultra strict validation to prevent bypassing the plan choice
+                        else if (extractedStr.includes('120') || extractedStr.includes('60')) {
+                            // AI detected a valid plan choice
+                            const plan = extractedStr.includes('120') ? '120' : '60';
+                            const product = currentState.selectedProduct || "Nuez de la India";
+
+                            currentState.selectedPlan = plan;
+                            currentState.selectedProduct = product;
+
+                            currentState.cart = [{
+                                product: product,
+                                plan: plan,
+                                price: _getPrice(product, plan)
+                            }];
+
+                            if (planAI.response) {
+                                currentState.history.push({ role: 'bot', content: planAI.response, timestamp: Date.now() });
+                                await sendMessageWithDelay(userId, planAI.response);
+                            }
+
+                            const closingNode = knowledge.flow.closing;
                             currentState.history.push({ role: 'bot', content: closingNode.response, timestamp: Date.now() });
                             await sendMessageWithDelay(userId, closingNode.response);
-                        }
 
-                        _setStep(currentState, closingNode.nextStep);
-                        saveState();
-                        matched = true;
-                    } else {
-                        // AI incorrectly marked goalMet=true without getting a plan number
-                        console.warn(`[AI-SAFEGUARD] waiting_plan_choice: AI returned goalMet=true but no 60/120 in extractedData (${extractedStr}). Downgrading to false.`);
-                        if (planAI.response) {
-                            currentState.history.push({ role: 'bot', content: planAI.response, timestamp: Date.now() });
-                            await sendMessageWithDelay(userId, planAI.response);
+                            _setStep(currentState, closingNode.nextStep);
+                            saveState();
                             matched = true;
+                        } else {
+                            // AI incorrectly marked goalMet=true without getting a plan number
+                            console.warn(`[AI-SAFEGUARD] waiting_plan_choice: AI returned goalMet=true but no 60/120 in extractedData (${extractedStr}). Downgrading to false.`);
+                            if (planAI.response) {
+                                currentState.history.push({ role: 'bot', content: planAI.response, timestamp: Date.now() });
+                                await sendMessageWithDelay(userId, planAI.response);
+                                matched = true;
+                            }
                         }
+                    } else if (planAI.response) {
+                        _handleExtractedData(userId, planAI.extractedData, currentState);
+                        currentState.history.push({ role: 'bot', content: planAI.response, timestamp: Date.now() });
+                        await sendMessageWithDelay(userId, planAI.response);
+                        matched = true;
                     }
-                } else if (planAI.response) {
-                    _handleExtractedData(userId, planAI.extractedData, currentState);
-                    currentState.history.push({ role: 'bot', content: planAI.response, timestamp: Date.now() });
-                    await sendMessageWithDelay(userId, planAI.response);
-                    matched = true;
                 }
-            }
+            } // <--- The actual missing closing brace for the outer interceptor else block
             break;
         }
 
@@ -1037,7 +1207,7 @@ async function processSalesFlow(userId, text, userState, knowledge, dependencies
             // SCRIPT FIRST: Clear affirmative confirmation
             else if (_isAffirmative(normalizedText)) {
                 // Point to closing since data_request is redundant/removed
-                const msg = _formatMessage(knowledge.flow.closing.response);
+                const msg = _formatMessage(knowledge.flow.closing.response, currentState);
                 _setStep(currentState, knowledge.flow.closing.nextStep);
                 currentState.history.push({ role: 'bot', content: msg, timestamp: Date.now() });
                 saveState();
@@ -1089,7 +1259,7 @@ async function processSalesFlow(userId, text, userState, knowledge, dependencies
                 else if (currentState.selectedProduct.includes('Gotas')) priceNode = knowledge.flow.preference_gotas;
                 else priceNode = knowledge.flow.preference_semillas;
 
-                const msg = _formatMessage(priceNode.response);
+                const msg = _formatMessage(priceNode.response, currentState);
                 _setStep(currentState, 'waiting_plan_choice');
                 currentState.history.push({ role: 'bot', content: msg, timestamp: Date.now() });
                 saveState();
@@ -1111,31 +1281,91 @@ async function processSalesFlow(userId, text, userState, knowledge, dependencies
                 if (newProduct && newProduct !== currentState.selectedProduct) {
                     console.log(`[BACKTRACK] User ${userId} changed product from "${currentState.selectedProduct}" to "${newProduct}" during waiting_data`);
                     const oldGoal = currentState.weightGoal; // Preserve if exists
+                    const oldPlan = currentState.selectedPlan; // Preserve if exists
+
                     currentState.selectedProduct = newProduct;
-                    currentState.cart = [];
                     currentState.pendingOrder = null;
-                    currentState.addressAttempts = 0;
                     if (oldGoal) currentState.weightGoal = oldGoal; // Restore
 
+                    // Extract 'postdatado' dates identically to waiting_preference
+                    const postdatadoMatch = normalizedText.match(/\b(lunes|martes|miercoles|mi├®rcoles|jueves|viernes|sabado|s├íbado|domingo|semana|mes|cobro|ma├▒ana|despues|despu├®s|principio|el \d+ de [a-z]+|el \d+)\b/i);
+                    if (postdatadoMatch && /\b(recibir|llega|enviar|mandar|cobro|pago|puedo|entregar)\b/i.test(normalizedText)) {
+                        console.log(`[LATE POSTDATADO] Captured in waiting_data swap: ${text}`);
+                        if (!currentState.postdatado) currentState.postdatado = text;
+                    }
 
-                    // Show new product prices and ask for plan
-                    let priceNode;
-                    if (newProduct.includes('C├ípsulas')) priceNode = knowledge.flow.preference_capsulas;
-                    else if (newProduct.includes('Gotas')) priceNode = knowledge.flow.preference_gotas;
-                    else priceNode = knowledge.flow.preference_semillas;
+                    if (oldPlan) {
+                        // User already selected a plan! Just swap the item and update price without resetting.
+                        const priceStr = _getPrice(newProduct, oldPlan);
+                        let basePrice = parseInt(priceStr.replace(/\./g, ''));
+                        currentState.cart = [{ item: newProduct, plan: oldPlan, price: priceStr }];
 
-                    const changeMsg = `┬íDale, sin problema! ­ƒÿè Cambiamos a ${newProduct.split(' de ')[0].toLowerCase()}.`;
-                    currentState.history.push({ role: 'bot', content: changeMsg, timestamp: Date.now() });
-                    await sendMessageWithDelay(userId, changeMsg);
+                        // Re-evaluate MAX and Delivery fees
+                        let finalAdicional = 0;
+                        if (currentState.isContraReembolsoMAX) {
+                            finalAdicional = oldPlan === 60 ? _getAdicionalMAX() : 0;
+                        }
+                        currentState.adicionalMAX = finalAdicional;
+                        const finalPrice = basePrice + finalAdicional;
+                        currentState.totalPrice = finalPrice.toLocaleString('es-AR').replace(/,/g, '.');
+
+                        const changeMsg = `┬íDale, sin problema! ­ƒÿè Cambiamos a ${newProduct.split(' de ')[0].toLowerCase()} por ${oldPlan} d├¡as, tienen un valor $${currentState.totalPrice}.`;
+                        currentState.history.push({ role: 'bot', content: changeMsg, timestamp: Date.now() });
+                        await sendMessageWithDelay(userId, changeMsg);
+
+                        let prefix = currentState.postdatado ? `Anotado para enviarlo en esa fecha ­ƒôà.` : ``;
+                        if (prefix) {
+                            currentState.history.push({ role: 'bot', content: prefix, timestamp: Date.now() });
+                            await sendMessageWithDelay(userId, prefix);
+                        }
 
-                    const priceMsg = _formatMessage(priceNode.response);
-                    currentState.history.push({ role: 'bot', content: priceMsg, timestamp: Date.now() });
-                    await sendMessageWithDelay(userId, priceMsg);
+                        saveState();
+                        // DO NOT return here! If the user sent address data ("marta pastor, benegas 77") 
+                        // in the same burst of messages (debounced by index.js), we must let execution
+                        // fall through to AI Address Parsing below, so the data is not lost.
+                    } else {
+                        // They hadn't selected a plan yet (rare during waiting_data, but fallback just in case)
+                        currentState.cart = [];
+                        currentState.addressAttempts = 0;
+
+                        let priceNode;
+                        if (newProduct.includes('C├ípsulas')) priceNode = knowledge.flow.preference_capsulas;
+                        else if (newProduct.includes('Gotas')) priceNode = knowledge.flow.preference_gotas;
+                        else priceNode = knowledge.flow.preference_semillas;
+
+                        const changeMsg = `┬íDale, sin problema! ­ƒÿè Cambiamos a ${newProduct.split(' de ')[0].toLowerCase()}.`;
+                        currentState.history.push({ role: 'bot', content: changeMsg, timestamp: Date.now() });
+                        await sendMessageWithDelay(userId, changeMsg);
+
+                        const priceMsg = _formatMessage(priceNode.response, currentState);
+                        currentState.history.push({ role: 'bot', content: priceMsg, timestamp: Date.now() });
+                        await sendMessageWithDelay(userId, priceMsg);
+
+                        // Check if we also need to append the Upsell message natively
+                        if (currentState.weightGoal && currentState.weightGoal > 10) {
+                            const upsell = "Personalmente yo te recomendar├¡a el de 120 d├¡as debido al peso que esperas perder ­ƒæî";
+                            currentState.history.push({ role: 'bot', content: upsell, timestamp: Date.now() });
+                            await sendMessageWithDelay(userId, upsell);
+                        }
 
-                    _setStep(currentState, 'waiting_plan_choice');
+                        _setStep(currentState, 'waiting_plan_choice');
+                        saveState();
+                        matched = true;
+                        return; // MUST return to prevent continuing into address processing
+                    }
+                } else if (newProduct === currentState.selectedProduct) {
+                    console.log(`[REDUNDANT] User ${userId} re-selected ${newProduct} in waiting_data`);
+                    let prefixIterated = `Ok, ${newProduct.split(' de ')[0].toLowerCase()} entonces ­ƒÿè. `;
+
+                    const postdatadoMatch = normalizedText.match(/\b(lunes|martes|miercoles|mi├®rcoles|jueves|viernes|sabado|s├íbado|domingo|semana|mes|cobro|ma├▒ana|despues|despu├®s|principio)\b/i);
+                    if (postdatadoMatch) {
+                        prefixIterated += `Anotado para enviarlo en esa fecha ­ƒôà. `;
+                    }
+
+                    currentState.history.push({ role: 'bot', content: prefixIterated, timestamp: Date.now() });
                     saveState();
-                    matched = true;
-                    break;
+                    await sendMessageWithDelay(userId, prefixIterated);
+                    // DO NOT return here, allow fall-through to address parser.
                 }
             }
 
@@ -1213,7 +1443,7 @@ async function processSalesFlow(userId, text, userState, knowledge, dependencies
             console.log("Analyzing address data with AI...");
             const data = await aiService.parseAddress(textToAnalyze);
 
-            let madeProgress = false; // Moved to outer scope
+
 
             if (data && !data._error) {
                 if (data.nombre && !currentState.partialAddress.nombre) { currentState.partialAddress.nombre = data.nombre; madeProgress = true; }
@@ -1336,7 +1566,6 @@ async function processSalesFlow(userId, text, userState, knowledge, dependencies
                 let addressSummary = `­ƒôï *Datos de env├¡o:*\n`;
                 addressSummary += `­ƒæñ ${addr.nombre}\n`;
                 addressSummary += `­ƒôì ${addr.calle}, ${addr.ciudad}\n`;
-                if (addr.provincia) addressSummary += `­ƒÅø´©Å ${addr.provincia}\n`;
                 addressSummary += `­ƒô« CP: ${addr.cp}`;
 
                 // If Google Maps validated, show formatted address
@@ -1344,22 +1573,20 @@ async function processSalesFlow(userId, text, userState, knowledge, dependencies
                     addressSummary += `\n\nÔ£à Direcci├│n verificada: ${validation.mapsFormatted}`;
                 }
 
-                // Warnings for admin (not shown to user)
-                const validationNotes = validation.warnings.length > 0
-                    ? `\nÔÜá´©Å Validaci├│n: ${validation.warnings.join(', ')}`
-                    : (validation.mapsValid ? '\nÔ£à Direcci├│n verificada por Google Maps' : '');
-
                 currentState.history.push({ role: 'bot', content: addressSummary, timestamp: Date.now() });
                 await sendMessageWithDelay(userId, addressSummary);
 
+                // Send 2nd part: The Order Confirmation Block
+                const summaryMsg = buildConfirmationMessage(currentState);
+                currentState.history.push({ role: 'bot', content: summaryMsg, timestamp: Date.now() });
+                await sendMessageWithDelay(userId, summaryMsg);
+
                 // Reset field re-ask counts on success
                 currentState.fieldReaskCount = {};
 
-                // Set step to waiting_admin_ok
-                _setStep(currentState, 'waiting_admin_ok');
+                // Skip waiting_admin_ok and go straight to waiting_final_confirmation
+                _setStep(currentState, 'waiting_final_confirmation');
                 saveState();
-
-                await notifyAdmin(`Pedido CASI completo`, userId, `Datos: ${addr.nombre}, ${addr.calle}\nCiudad: ${addr.ciudad} | CP: ${addr.cp}\nProvincia: ${addr.provincia || '?'}${validationNotes}\nItems: ${cartSummary}\nSubtotal: $${subtotal}${maxLabel}\nTotal: $${currentState.totalPrice}`);
                 matched = true;
             } else if (currentState.addressAttempts >= 5) {
                 // Too many attempts ÔÇö pause and alert admin (Increased limit from 3 to 5)
@@ -1435,6 +1662,53 @@ async function processSalesFlow(userId, text, userState, knowledge, dependencies
         }
 
         case 'waiting_final_confirmation': {
+            // PRIORITY 0: Detect product change ("mejor semillas", "quiero capsulas", "cambio a gotas") BEFORE confirming
+            const productChangeMatch = normalizedText.match(/\b(mejor|quiero|prefiero|cambio|cambia|dame|paso a|en vez)\b.*\b(capsula|capsulas|pastilla|pastillas|semilla|semillas|gota|gotas|natural|infusion)\b/i)
+                || normalizedText.match(/\b(capsula|capsulas|pastilla|pastillas|semilla|semillas|gota|gotas)\b.*\b(mejor|quiero|prefiero|cambio|en vez)\b/i);
+
+            if (productChangeMatch && currentState.selectedPlan) {
+                // Detect which product they want
+                let newProduct = null;
+                if (/capsula|pastilla/i.test(normalizedText)) newProduct = "C├ípsulas de nuez de la india";
+                else if (/semilla|natural|infusion/i.test(normalizedText)) newProduct = "Semillas de nuez de la india";
+                else if (/gota/i.test(normalizedText)) newProduct = "Gotas de nuez de la india";
+
+                if (newProduct && newProduct !== currentState.selectedProduct) {
+                    console.log(`[LATE-BACKTRACK] User ${userId} changed product from "${currentState.selectedProduct}" to "${newProduct}" during final confirmation`);
+
+                    currentState.selectedProduct = newProduct;
+                    const oldPlan = currentState.selectedPlan;
+
+                    // Recalculate cart and price
+                    const priceStr = _getPrice(newProduct, oldPlan);
+                    let basePrice = parseInt(priceStr.replace(/\./g, ''));
+                    currentState.cart = [{ product: newProduct, plan: oldPlan, price: priceStr }];
+
+                    // Re-evaluate MAX and Delivery fees
+                    let finalAdicional = 0;
+                    if (currentState.isContraReembolsoMAX) {
+                        finalAdicional = oldPlan === '60' ? _getAdicionalMAX() : 0;
+                    }
+                    currentState.adicionalMAX = finalAdicional;
+                    const finalPrice = basePrice + finalAdicional;
+                    currentState.totalPrice = finalPrice.toLocaleString('es-AR').replace(/,/g, '.');
+
+                    // Acknowledge change
+                    const changeMsg = `┬íDale, sin problema! ­ƒÿè Cambiamos el pedido a ${newProduct.split(' de ')[0].toLowerCase()}.`;
+                    currentState.history.push({ role: 'bot', content: changeMsg, timestamp: Date.now() });
+                    await sendMessageWithDelay(userId, changeMsg);
+
+                    // Re-send confirmation summary
+                    const summaryMsg = buildConfirmationMessage(currentState);
+                    currentState.history.push({ role: 'bot', content: summaryMsg, timestamp: Date.now() });
+                    await sendMessageWithDelay(userId, summaryMsg);
+
+                    saveState();
+                    matched = true;
+                    return; // Stay in 'waiting_final_confirmation'
+                }
+            }
+
             // Helper ÔÇö build orderData object from state (avoids 3 duplicate blocks)
             const _buildOrderData = (extra = {}) => {
                 const o = currentState.pendingOrder || {};
@@ -1497,6 +1771,10 @@ async function processSalesFlow(userId, text, userState, knowledge, dependencies
                     appendOrderToSheet(orderData).catch(e => console.error('­ƒö┤ [SHEETS] Async log failed:', e.message));
                     console.log(`Ô£à [PEDIDO CONFIRMADO] ${userId} ÔÇö Total: $${currentState.totalPrice || '0'}`);
 
+                    // Notify Admin Now
+                    const o = currentState.pendingOrder;
+                    await notifyAdmin(`Ô£à Nuevo Pedido Confirmado`, userId, `Datos: ${o.nombre}, ${o.calle}\nCiudad: ${o.ciudad} | CP: ${o.cp}\nProvincia: ${o.provincia || '?'}\nItems: ${orderData.producto}\nTotal: $${currentState.totalPrice || '0'}`);
+
                     // --- METRICS TRACKING ---
                     if (dependencies.config && dependencies.config.scriptStats && dependencies.config.activeScript) {
                         if (!dependencies.config.scriptStats[dependencies.config.activeScript]) {
diff --git a/src/services/ai.js b/src/services/ai.js
index fae8803..44987da 100644
--- a/src/services/ai.js
+++ b/src/services/ai.js
@@ -577,14 +577,17 @@ INSTRUCCIONES:
         - ciudad: Localidad o ciudad (ej: "Valle Viejo", "El Ba├▒ado", "Gualeguay").
         - provincia: Provincia de Argentina (ej: "Catamarca", "C├│rdoba", "Entre R├¡os").
         - cp: C├│digo postal num├®rico (ej: "4707", "5000").
+        - postdatado: Si el cliente pide enviar o recibir el pedido en una fecha futura (ej: "mandamelo el 10", "cobro a principio de mes", "para la semana que viene"). Guardar la fecha/referencia literal o null.
         
         REGLAS Y CONTEXTO GEOGR├üFICO:
         1. Tu prioridad es extraer CUALQUIER dato ├║til, aunque falten otros.
         2. "Gualeguay" y "Gualeguaych├║" pertenecen a la provincia de Entre R├¡os, NO a Santa Fe.
         3. Barrios como "Barrio 60 viviendas" o "mz F casa 4" van en "calle".
-        4. Si el texto comienza con palabras que parecen un nombre de persona (ej: "Horacio giosue benegas 77"), separa el nombre de persona en "nombre" y la calle en "calle".
+        4. CR├ìTICO: Separa correctamente el NOMBRE DE PERSONA del NOMBRE DE LA CALLE. 
+           Si te dicen "marta pastor bengas 77", "marta pastor" es el nombre y "bengas 77" es la calle. No pongas apellidos como parte de la calle ni calles como parte del apellido. EXTRAE SIEMPRE el nombre de la persona, incluso si coincide con el tuyo ("Marta").
         5. Si el usuario env├¡a SOLO SU NOMBRE (ej: "Juan", "Pedro Pablo"), extraelo como "nombre", y devuelve los dem├ís como null.
         6. Si el texto dice claramente de qu├® provincia es, respetalo aunque no coincida con el c├│digo postal.
+        7. Las Avenidas o calles a veces est├ín abreviadas (ej: "av belgrano 45D").
         
         Devolver JSON PURO:
         {
@@ -592,7 +595,8 @@ INSTRUCCIONES:
           "calle": "string o null",
           "ciudad": "string o null",
           "provincia": "string o null",
-          "cp": "string o null"
+          "cp": "string o null",
+          "postdatado": "string o null"
         }
         `;
         try {
diff --git a/src/services/scheduler.js b/src/services/scheduler.js
index 17fef70..6df5430 100644
--- a/src/services/scheduler.js
+++ b/src/services/scheduler.js
@@ -126,8 +126,10 @@ function autoApproveOrders(sharedState, dependencies) {
                 const prodStr = cart.map(i => i.product).join(' + ');
                 const planStr = cart.map(i => `${i.plan} d├¡as`).join(' + ');
 
+                // Clean userId for Sheets (get only the phone number)
+                const phone = userId.split('@')[0];
                 const orderData = {
-                    cliente: userId,
+                    cliente: phone,
                     nombre: o.nombre, calle: o.calle, ciudad: o.ciudad, cp: o.cp,
                     producto: prodStr, plan: planStr,
                     precio: state.totalPrice || '0',
